---
title: Spring Testing
permalink: /pages/spring/testing/
article: true
date: 2022-05-26 23:00:25
---

# 测试

> 5.3.2

本章介绍了Spring对集成测试的支持和单元测试的最佳实践。Spring团队倡导测试驱动的开发（TDD）。Spring团队发现，正确使用控制反转（IOC）确实使单元和集成测试更加容易（因为存在setter 方法和类上适当的构造函数，因此无需设置服务定位器注册表和类似结构就能很容的把它们联系在一起）。

# 1. 介绍Spring Testing

测试是企业软件开发的组成部分。本章重点介绍了IOC原理为单元测试增添的价值以及Spring 框架对集成测试支持的好处。（企业中对测试的=处理超出了本参考手册的范围。）

# 2. 单元测试

依赖注入应降低代码对容器的依赖，而不是像传统的Java EE开发那样。构成您应用程序的POJOs应该在JUnit 或TestNG 测试中可进行测试，并通过使用new操作符，不需要使用Spring或任何其他容器来实例化对象。您可以使用 [mock objects](https://docs.spring.io/spring-framework/docs/5.3.2/reference/html/testing.html#mock-objects)（与其他有价值的测试技术结合使用）来隔离测试代码。如果您遵循有关Spring的体系结构建议，则代码库的清洁分层和组件促进了更容易的单元测试。例如，您可以通过stub或mock DAO或仓储层接口来测试服务层对象，而无需在运行单元测试时访问持久数据。

真正的单元测试通常非常快地运行，因为没有运行时基础架构可以设置。真正的单位测试作为开发方法的一部分可以提高您的生产效率。您可能不需要测试章节的这一部分来帮助您为基于IOC的应用程序编写有效的单元测试。但是，对于某些单元测试方案，Spring框架提供了mock对象和测试支持类，这将在本章中进行描述。

## 2.1. Mock对象

Spring包括许多专门用于mock的软件包：

- [Environment](https://docs.spring.io/spring-framework/docs/5.3.2/reference/html/testing.html#mock-objects-env)
- [JNDI](https://docs.spring.io/spring-framework/docs/5.3.2/reference/html/testing.html#mock-objects-jndi)
- [Servlet API](https://docs.spring.io/spring-framework/docs/5.3.2/reference/html/testing.html#mock-objects-servlet)
- [Spring Web Reactive](https://docs.spring.io/spring-framework/docs/5.3.2/reference/html/testing.html#mock-objects-web-reactive)

### 2.1.1. Environment

`org.springframework.mock.env`软件包包含`Environment`和`PropertySource`抽象的模拟实现（请参阅[Bean Definition Profiles](https://docs.spring.io/spring-framework/docs/5.3.2/reference/html/core.html#beans-definition-profiles)和[`PropertySource` Abstraction](https://docs.spring.io/spring-framework/docs/5.3.2/reference/html/core.html#beans-property-source-abstraction)）。`MockEnvironment`和模拟`MockPropertySource`对于开发容器外的依赖于特定环境属性代码的测试很有用。



### 2.1.2. JNDI

`org.springframework.mock.jndi`软件包包含JNDI SPI的部分实现，您可以使用它来为测试套件或独立应用程序设置简单的JNDI环境。例如，如果JDBC `DataSource`实例与Java EE容器中的测试代码绑定到相同的JNDI名称，则可以在未经修改的情况下重复使用应用程序代码和配置。

·:warning:`org.springframework.mock.jndi`软件包中的模拟JNDI支持正式在Spring 5.2正式弃用，因为其已支持[Simple-JNDI](https://github.com/h-thurow/Simple-JNDI)等第三方的完整解决方案。

### 2.1.3. Servlet API

`org.springframework.mock.web`软件包包含一组全面的Servlet API模拟对象，这些对象可用于测试Web上下文，控制器和过滤器。这些模拟对象针对的是使用Spring Web MVC框架的应用，且通常比动态模拟对象（例如[EasyMock](http://easymock.org/)）或可替代的Servlet API模拟对象（例如[MockObjects](http://www.mockobjects.com/)）更方便使用。

> :bulb:从Spring 5.0起，`org.springframework.mock.web`中的模拟对象基于Servlet 4.0 API。

Spring MVC测试框架在模拟Servlet  API对象上构建，为Spring MVC提供集成测试框架。请参阅[MockMvc](https://docs.spring.io/spring-framework/docs/5.3.2/reference/html/testing.html#spring-mvc-test-framework)。

### 2.1.4. Spring Web Reactive

`org.springframework.mock.http.server.reactive`软件包包含`ServerHttpRequest`和`ServerHttpRequest`的模拟实现，可用于WebFlux应用程序。`org.springframework.mock.web.server`软件包包含一个取决于模拟请求和响应对象的模拟`ServerWebExchange`。

`MockServerHttpRequest`和`MockServerHttpResponse`都继承服务器特定实现的抽象基类，并与他们共享行为。例如，一旦创建了一个不可变的模拟请求，但是您可以使用`ServerHttpRequest`的`mutate()`方法来创建可修改的实例。

为了使模拟响应正确实现写入归约并返回写入完成句柄（即`Mono<Void>`），默认情况下，它使用Flux的cache().then()，缓冲数据并使其在测试中可用于断言。应用程序可以设置自定义写入功能（例如，测试无限流）。

[WebTestClient](https://docs.spring.io/spring-framework/docs/5.3.2/reference/html/testing.html#webtestclient)在模拟请求和响应上构建，以提供没有HTTP服务器的WebFlux应用程序的支持。客户也可以使用运行服务器用于端到端测试。

## 2.2. 单元测试支持类

Spring包括许多可以帮助单元测试的类。他们分为两类：

- [一般测试工具类](https://docs.spring.io/spring-framework/docs/5.3.2/reference/html/testing.html#unit-testing-utilities)
- [Spring MVC测试工具类](https://docs.spring.io/spring-framework/docs/5.3.2/reference/html/testing.html#unit-testing-spring-mvc)

### 2.2.1. 一般测试工具类

`org.springframework.test.util`软件包包含多个通用工具方法，用于单元和集成测试。

`ReflectionTestUtils`是基于反射的工具方法的集合。您可以在测试场景中使用这些方法，在这些场景中，您需要更改常数的值，设置非public字段，调用非public setter方法，或调用非public配置或生命周期回调方法，例如以下内容：

- ORM 框架 (例如JPA和 Hibernate) condone private或protected的字段访问，而不是领域实体中属性的public setter方法。
- Spring对注解的支持（例如`@Autowired`，`@Inject`和`@Resource`），可为private或protected字段，setter方法和配置方法提供依赖注入。
- 使用`@PostConstruct`和`@PreDestroy`等注解用于生命周期回调方法。

[`AopTestUtils`](https://docs.spring.io/spring-framework/docs/5.3.2/javadoc-api/org/springframework/test/util/AopTestUtils.html)是与AOP相关的工具方法的集合。您可以使用这些方法来获取隐藏在一个或多个Spring代理后面的基础目标对象的引用。例如，如果您通过使用EasyMock或Mockito之类的库将bean配置为动态mock，并且该模拟包裹在Spring 代理中，则可能需要直接访问基础模拟以对其进行配置并执行验证。有关Spring的核心AOP工具方法，请参阅[`AopUtils`](https://docs.spring.io/spring-framework/docs/5.3.2/javadoc-api/org/springframework/aop/support/AopUtils.html)和[`AopProxyUtils`](https://docs.spring.io/spring-framework/docs/5.3.2/javadoc-api/org/springframework/aop/framework/AopProxyUtils.html)。

### 2.2.2. Spring MVC 测试工具类

`org.springframework.test.web`软件包包含[`ModelAndViewAssert`](https://docs.spring.io/spring-framework/docs/5.3.2/javadoc-api/org/springframework/test/web/ModelAndViewAssert.html)，您可以将其与JUnit，TestNG或任何其他测试框架结合使用，用于与Spring MVC ModelAndView对象进行的单元测试。

> :bulb:**单元测试Spring MVC Controllers**
>
> 要将Spring MVC Controller类视为POJOs进行单元测试，请将ModelAndViewAssert与Spring的[Servlet API mocks](https://docs.spring.io/spring-framework/docs/5.3.2/reference/html/testing.html#mock-objects-servlet)中的MockHttpServletRequest，MockHttpSession等等结合使用。要用Spring MVC的WebApplicationContext配置结合使用Spring MVC和REST Controller类进行集成测试，请改用 [Spring MVC Test Framework](https://docs.spring.io/spring-framework/docs/5.3.2/reference/html/testing.html#spring-mvc-test-framework)。

# 3. 集成测试

本章（本章的其余大部分）涵盖了spring应用程序的集成测试。它包括以下主题：

- [Overview](https://docs.spring.io/spring-framework/docs/5.3.2/reference/html/testing.html#integration-testing-overview)
- [Goals of Integration Testing](https://docs.spring.io/spring-framework/docs/5.3.2/reference/html/testing.html#integration-testing-goals)
- [JDBC Testing Support](https://docs.spring.io/spring-framework/docs/5.3.2/reference/html/testing.html#integration-testing-support-jdbc)
- [Annotations](https://docs.spring.io/spring-framework/docs/5.3.2/reference/html/testing.html#integration-testing-annotations)
- [Spring TestContext Framework](https://docs.spring.io/spring-framework/docs/5.3.2/reference/html/testing.html#testcontext-framework)
- [MockMvc](https://docs.spring.io/spring-framework/docs/5.3.2/reference/html/testing.html#spring-mvc-test-framework)



## 3.1. 概述

无需部署到应用程序服务器或连接到其他企业基础架构就能够执行一些集成测试很重要。这样做可以让您测试以下内容：

- Spring IoC 容器上下文的正确装配
- 使用JDBC或ORM工具访问数据。这可以包括SQL语句，Hibernate 查询，JPA实体映射等。

Spring框架在spring-test模块中提供了一流的支持。实际的JAR文件的名称可能包括发行版本，也可能是org.springframework.test形式，具体取决于您从何处获得的（请参阅 [section on Dependency Management](https://docs.spring.io/spring-framework/docs/5.3.2/reference/html/core.html#dependency-management)）。

该库包括org.springframework.test软件包，其中包含用于与Spring容器集成测试的有价值的类。该测试不依赖应用程序服务器或其他部署环境。此类测试的运行速度比单元测试要慢，但是比依靠部署到应用程序服务器的测试或远程测试要快得多。

单位和集成测试支持以注解驱动的 [Spring TestContext Framework](https://docs.spring.io/spring-framework/docs/5.3.2/reference/html/testing.html#testcontext-framework)的形式提供。TestContext框架对实际使用测试框架不可知，该框架允许在包括JUnit，TestNG等各种环境中的测试工具。



## 3.2. 集成测试的目标

Spring的集成测试支持以下主要目标：

- 管理测试间的[Spring IoC container caching](https://docs.spring.io/spring-framework/docs/5.3.2/reference/html/testing.html#testing-ctx-management)
- 提供 [Dependency Injection of test fixture instances](https://docs.spring.io/spring-framework/docs/5.3.2/reference/html/testing.html#testing-fixture-di).
- 提供适合集成测试的 [transaction management](https://docs.spring.io/spring-framework/docs/5.3.2/reference/html/testing.html#testing-tx) 
- 提供 [Spring-specific base classes](https://docs.spring.io/spring-framework/docs/5.3.2/reference/html/testing.html#testing-support-classes) ，以帮助开发人员编写集成测试。



### 3.2.1. 上下文管理和缓存

Spring TestContext框架提供了Spring ApplicationContext 实例和WebApplicationContext 实例的一致加载以及这些上下文的缓存。支持加载上下文的缓存非常重要，因为启动时间可能会成为一个问题 - 不是因为Spring本身的开销，而是因为Spring容器实例化的对象需要时间来实例化。例如，一个具有50至100个Hibernate 映射文件的项目可能需要10到20秒才能加载映射文件，在每个测试中承担这样的开销导致整体测试运行较慢，从而降低了开发人员的生产效率。

测试类通常会声明XML格式的一系列资源位置或Groovy配置元数据（通常在类路径中）或用于配置应用程序的组件类数组。这些位置或类与web.xmll中指定的或其他配置文件相同或相似。

默认情况下，加载后，为每个测试重复使用了配置的ApplicationContext。因此，每个测试套件仅产生一次设置成本，随后的测试执行速度要快得多。在这种情况下，“测试套件”一词是指在同一JVM中运行的所有测试--例如，所有测试都来自给定项目或模块的 Ant, Maven, 或Gradle  构建。在不太可能的情况下，测试破坏了应用程序上下文并需要重新加载（例如，通过修改bean定义或应用程序对象的状态）可以配置TestContext 框架以重新加载配置并在执行下一个应用程序之前重建应用程序上下文测试。

请参阅 TestContext框架的[Context Management](https://docs.spring.io/spring-framework/docs/5.3.2/reference/html/testing.html#testcontext-ctx-management)和 [Context Caching](https://docs.spring.io/spring-framework/docs/5.3.2/reference/html/testing.html#testcontext-ctx-management-caching)。

### 3.2.2. 测试的依赖注入

当TestContext 框架加载您的应用程序上下文时，它可以选择使用依赖项注入来配置测试类的实例。这提供了一种方便的机制，可通过使用应用程序上下文预配置的Bean来设置测试。这里的一个很大的好处是，您可以在各种测试场景中重复使用应用程序上下文（例如，用于配置Spring管理对象图，事务代理，数据源实例等），从而避免需要复制复杂的测试固定设置以进行单个测试案例。

例如，考虑一个场景，其中我们有一个类（HibernateTitleRepository），该类实现了Title域实体的数据访问逻辑。我们想编写测试以下领域的集成测试：

- Spring配置：基本上，所有内容是否与HibernateTitleRepository Bean的配置有关？
- Hibernate 映射文件配置：所有内容是否正确映射，并且是否适当地进行懒加载设置？
- HibernateTitleRepository的逻辑：该类配置的实例是否按预期执行？

请参阅使用[TestContext framework](https://docs.spring.io/spring-framework/docs/5.3.2/reference/html/testing.html#testcontext-fixture-di)的测试的依赖注入。

### 3.2.3. 事务管理

在访问真实数据库的测试中，一个常见问题是它们对持久存储状态的影响。即使您使用开发数据库，对状态的更改也可能影响未来的测试。同样，在事务之外，无法执行（或验证）许多操作（例如插入或修改持久数据）。

TestContext框架解决了此问题。默认情况下，该框架为每个测试创建并回滚事务。您编写代码时可以假定事务存在。如果您在测试中调用事务代理对象，则根据配置的事务语义，它们能正确工作。

另外，如果测试方法在用于测试的事务中运行时删除了所选表的内容，则默认情况下的事务将回滚，并且数据库在执行测试之前返回其状态。通过使用测试应用程序上下文中定义的PlatformTransactionManager bean，向测试提供了事务支持。

如果您想进行事务提交（不寻常，但当您希望特定测试填充或修改数据库时偶尔有用），可以告诉TestContext框架通过使用[`@Commit`](https://docs.spring.io/spring-framework/docs/5.3.2/reference/html/testing.html#integration-testing-annotations) 使事务提交，而不是回滚。

请参阅[TestContext framework](https://docs.spring.io/spring-framework/docs/5.3.2/reference/html/testing.html#testcontext-tx)的事务管理。

### 3.2.4. 集成测试支持类

Spring TestContext框架提供了几个抽象支持类，以简化集成测试的编写。这些基本测试类提供了明确定义的钩子，并在测试框架中提供了方便的实例变量和方法，可让您访问：

- `ApplicationContext`，用于执行明确的Bean查找或测试整个上下文的状态。
-  `JdbcTemplate`，用于执行SQL语句查询数据库。您可以使用此类查询在执行与数据库相关的应用程序代码之前和之后确认数据库状态，并确保此类查询在与应用程序代码相同的事务范围内运行。与ORM工具一起使用时，请务必避免 [false positives](https://docs.spring.io/spring-framework/docs/5.3.2/reference/html/testing.html#testcontext-tx-false-positives)。

此外，您可能需要创建自定义的，应用程序范围的超类，并使用实例变量和特定于项目的方法。

请参阅[TestContext framework](https://docs.spring.io/spring-framework/docs/5.3.2/reference/html/testing.html#testcontext-tx)的支持类。

## 3.3. JDBC测试支持

org.springframework.test.jdbc软件包包含JdbcTestUtils，它是JDBC相关的工具函数的集合，旨在简化标准数据库测试方案。具体而言，JdbcTestUtils提供了以下静态工具方法：

- `countRowsInTable(..)`: 计算给定表中的行数。
- `countRowsInTableWhere(..)`: 使用提供的Where子句来计算给定表中的行数。
- `deleteFromTables(..)`: 从指定的表中删除所有行。
- `deleteFromTableWhere(..)`: 使用提供的Where子句从给定表中删除行。
- `dropTables(..)`: drop指定的表。

> :bulb:[`AbstractTransactionalJUnit4SpringContextTests`](https://docs.spring.io/spring-framework/docs/5.3.2/reference/html/testing.html#testcontext-support-classes-junit4)和[`AbstractTransactionalTestNGSpringContextTests`](https://docs.spring.io/spring-framework/docs/5.3.2/reference/html/testing.html#testcontext-support-classes-testng)提供了便利的方法，可将上述方法委派给JdbcTestUtils中的方法。
>
> spring-jdbc模块提供了配置和启动嵌入式数据库的支持，您可以在与数据库交互的集成测试中使用。有关详细信息，请参阅[Embedded Database Support](https://docs.spring.io/spring-framework/docs/5.3.2/reference/html/data-access.html#jdbc-embedded-database-support) 和 [Testing Data Access Logic with an Embedded Database](https://docs.spring.io/spring-framework/docs/5.3.2/reference/html/data-access.html#jdbc-embedded-database-dao-testing)。



## 3.4. 注解

本节涵盖了测试Spring应用程序时可以使用的注解。它包括以下主题：

- [Spring Testing Annotations](https://docs.spring.io/spring-framework/docs/5.3.2/reference/html/testing.html#integration-testing-annotations-spring)
- [Standard Annotation Support](https://docs.spring.io/spring-framework/docs/5.3.2/reference/html/testing.html#integration-testing-annotations-standard)
- [Spring JUnit 4 Testing Annotations](https://docs.spring.io/spring-framework/docs/5.3.2/reference/html/testing.html#integration-testing-annotations-junit4)
- [Spring JUnit Jupiter Testing Annotations](https://docs.spring.io/spring-framework/docs/5.3.2/reference/html/testing.html#integration-testing-annotations-junit-jupiter)
- [Meta-Annotation Support for Testing](https://docs.spring.io/spring-framework/docs/5.3.2/reference/html/testing.html#integration-testing-annotations-meta)



### 3.4.1. Spring Testing注解

Spring框架提供了以下一组特定于Spring的注解，您可以在单元测试和集成测试中使用，并与TestContext 框架结合使用。有关更多信息，请参见相应的Javadoc，包括默认属性值，属性别名和其他详细信息。

Spring的测试注解包括以下内容：

- [`@BootstrapWith`](https://docs.spring.io/spring-framework/docs/5.3.2/reference/html/testing.html#spring-testing-annotation-bootstrapwith)
- [`@ContextConfiguration`](https://docs.spring.io/spring-framework/docs/5.3.2/reference/html/testing.html#spring-testing-annotation-contextconfiguration)
- [`@WebAppConfiguration`](https://docs.spring.io/spring-framework/docs/5.3.2/reference/html/testing.html#spring-testing-annotation-webappconfiguration)
- [`@ContextHierarchy`](https://docs.spring.io/spring-framework/docs/5.3.2/reference/html/testing.html#spring-testing-annotation-contexthierarchy)
- [`@ActiveProfiles`](https://docs.spring.io/spring-framework/docs/5.3.2/reference/html/testing.html#spring-testing-annotation-activeprofiles)
- [`@TestPropertySource`](https://docs.spring.io/spring-framework/docs/5.3.2/reference/html/testing.html#spring-testing-annotation-testpropertysource)
- [`@DynamicPropertySource`](https://docs.spring.io/spring-framework/docs/5.3.2/reference/html/testing.html#spring-testing-annotation-dynamicpropertysource)
- [`@DirtiesContext`](https://docs.spring.io/spring-framework/docs/5.3.2/reference/html/testing.html#spring-testing-annotation-dirtiescontext)
- [`@TestExecutionListeners`](https://docs.spring.io/spring-framework/docs/5.3.2/reference/html/testing.html#spring-testing-annotation-testexecutionlisteners)
- [`@Commit`](https://docs.spring.io/spring-framework/docs/5.3.2/reference/html/testing.html#spring-testing-annotation-commit)
- [`@Rollback`](https://docs.spring.io/spring-framework/docs/5.3.2/reference/html/testing.html#spring-testing-annotation-rollback)
- [`@BeforeTransaction`](https://docs.spring.io/spring-framework/docs/5.3.2/reference/html/testing.html#spring-testing-annotation-beforetransaction)
- [`@AfterTransaction`](https://docs.spring.io/spring-framework/docs/5.3.2/reference/html/testing.html#spring-testing-annotation-aftertransaction)
- [`@Sql`](https://docs.spring.io/spring-framework/docs/5.3.2/reference/html/testing.html#spring-testing-annotation-sql)
- [`@SqlConfig`](https://docs.spring.io/spring-framework/docs/5.3.2/reference/html/testing.html#spring-testing-annotation-sqlconfig)
- [`@SqlMergeMode`](https://docs.spring.io/spring-framework/docs/5.3.2/reference/html/testing.html#spring-testing-annotation-sqlmergemode)
- [`@SqlGroup`](https://docs.spring.io/spring-framework/docs/5.3.2/reference/html/testing.html#spring-testing-annotation-sqlgroup)

**`@BootstrapWith`**

`@BootstrapWith`是一个类级别注解，您可以用来配置Spring TestContext框架的自动化方式。具体来说，您可以使用@BootstrapWith指定自定义TestContextBootstrapper。有关更多详细信息，请参见[bootstrapping the TestContext framework](https://docs.spring.io/spring-framework/docs/5.3.2/reference/html/testing.html#testcontext-bootstrapping) 。

**`@ContextConfiguration`**

`@ContextConfiguration`定义类别元数据，用于确定如何为集成测试加载和配置ApplicationContext。具体而言，@ContextConfiguration声明应用程序上下文资源位置或用于加载上下文的组件类。

资源位置通常是位于类路径中的XML配置文件或Groovy脚本，而组件类通常为@Configuration类。但是，资源位置还可以引用文件系统中的文件和脚本，并且组件类可以是@Component类，@Service类等。有关更多详细信息，请参见[Component Classes](https://docs.spring.io/spring-framework/docs/5.3.2/reference/html/testing.html#testcontext-ctx-management-javaconfig-component-classes) 。

下面的示例显示了@ContextConfiguration引用XML文件：

```java
@ContextConfiguration("/test-config.xml") 
class XmlApplicationContextTests {
    // class body...
}
```

以下示例显示了@ContextConfiguration引用类：

```java
@ContextConfiguration(classes = TestConfig.class) 
class ConfigClassApplicationContextTests {
    // class body...
}
```

作为替代方案或声明资源位置或组件类，您还可以使用@ContextConfiguration来声明ApplicationContextInitializer类。以下示例显示了这样的情况：

```java
@ContextConfiguration(initializers = CustomContextIntializer.class) 
class ContextInitializerTests {
    // class body...
}
```

您可以选择使用@ContextConfiguration来声明ContextLoader策略。但是，请注意，您通常不需要明确配置加载器，因为默认加载器支持initializers和locations或classes。

以下示例同时使用location 和loader：

```java
@ContextConfiguration(locations = "/test-context.xml", loader = CustomContextLoader.class) 
class CustomLoaderXmlApplicationContextTests {
    // class body...
}
```



> :information_source:@ContextConfiguration为继承资源位置或配置类以及通过超类或包装(enclosing)类声明的上下文初始化器提供了支持。

有关更多详细信息，请参见[Context Management](https://docs.spring.io/spring-framework/docs/5.3.2/reference/html/testing.html#testcontext-ctx-management), [`@Nested` test class configuration](https://docs.spring.io/spring-framework/docs/5.3.2/reference/html/testing.html#testcontext-junit-jupiter-nested-test-configuration) javadocs。

**`@WebAppConfiguration`**

`@WebAppConfiguration`是类级别注释，您可以用它来声明应用程序上下文应该是WebApplicationContext的集成测试。测试类中仅使用@WebAppConfiguration，就可确保使用"file:src/main/webapp"（即资源基本路径）的默认值为测试加载WebApplicationContext。该场景后的资源基础路径用来创建MockServletContext，以ServletContext角色为测试WebApplicationContext服务。

以下示例显示如何使用@WebAppConfiguration：

```java
@ContextConfiguration
@WebAppConfiguration 
class WebAppTests {
    // class body...
}
```

要覆盖默认值，您可以使用隐式value属性来指定不同的基本资源路径。`classpath:`和`file:`前缀都支持。如果没有提供资源前缀，则假定该路径为文件系统资源。以下示例显示了如何指定类路径资源：

```java
@ContextConfiguration
@WebAppConfiguration("classpath:test-web-resources") 
class WebAppTests {
    // class body...
}
```

请注意，@WebAppConfiguration必须与@ContextConfiguration一起使用，无论是在单个测试类中还是在测试类层次结构中。有关更多详细信息，请参见[`@WebAppConfiguration`](https://docs.spring.io/spring-framework/docs/5.3.2/javadoc-api/org/springframework/test/context/web/WebAppConfiguration.html) javadoc。

**`@ContextHierarchy`**

@ContextHierarchy是一个类级别注解，用于定义集成测试的ApplicationContext 实例的层次结构。@ContextHierarchy应该和一个或多个@ContextConfiguration实例的列表一起声明，每个列表在上下文层次结构中定义了一个级别。以下示例展示了在单个测试类中使用@ContextHierarchy（@ContextHierarchy也可以在测试类层次结构中使用）：

```java
@ContextHierarchy({
    @ContextConfiguration("/parent-config.xml"),
    @ContextConfiguration("/child-config.xml")
})
class ContextHierarchyTests {
    // class body...
}
```

```java
@WebAppConfiguration
@ContextHierarchy({
    @ContextConfiguration(classes = AppConfig.class),
    @ContextConfiguration(classes = WebConfig.class)
})
class WebIntegrationTests {
    // class body...
}
```

如果您需要合并或覆盖测试类层次结构中为给定级别的上下文层次结构配置，则必须通过显示提供在每个类层次结构中的对应级别的@ContextConfigurationname的name属性来命名此级别。有关进一步的示例，请参见 [Context Hierarchies](https://docs.spring.io/spring-framework/docs/5.3.2/reference/html/testing.html#testcontext-ctx-management-ctx-hierarchies) 和[`@ContextHierarchy`](https://docs.spring.io/spring-framework/docs/5.3.2/javadoc-api/org/springframework/test/context/ContextHierarchy.html) javadoc。

**`@ActiveProfiles`**

@ActiveProfiles是一个类级别注解，用于声明在加载ApplicationContext以进行集成测试时，使用哪个bean定义配置文件。

以下示例表明应激活dev配置文件：

```java
@ContextConfiguration
@ActiveProfiles("dev") 
class DeveloperTests {
    // class body...
}
```

以下示例表明应激活dev和integration配置文件：

```java
@ContextConfiguration
@ActiveProfiles({"dev", "integration"}) 
class DeveloperIntegrationTests {
    // class body...
}
```

> :information_source:@ActiveProfiles为继承超类和包装类声明的激活的bean定义配置文件提供了支持。您还可以通过实现自定义的[`ActiveProfilesResolver`](https://docs.spring.io/spring-framework/docs/5.3.2/reference/html/testing.html#testcontext-ctx-management-env-profiles-ActiveProfilesResolver)并使用@ActiveProfiles的resolver属性来编程式解析激活的bean定义配置文件。

有关示例和更多详细信息，请参见[Context Configuration with Environment Profiles](https://docs.spring.io/spring-framework/docs/5.3.2/reference/html/testing.html#testcontext-ctx-management-env-profiles), [`@Nested` test class configuration](https://docs.spring.io/spring-framework/docs/5.3.2/reference/html/testing.html#testcontext-junit-jupiter-nested-test-configuration)和 [`@ActiveProfiles`](https://docs.spring.io/spring-framework/docs/5.3.2/javadoc-api/org/springframework/test/context/ActiveProfiles.html) javadoc。

**`@TestPropertySource`**

@TestPropertySource是一个类级别注解，您可以用来配置属性文件的位置和内联属性的位置，改内联属性会添加到集成测试中已加载的ApplicationContext的Environment中的PropertySources。

以下示例演示了如何从类路径声明属性文件：

```java
@ContextConfiguration
@TestPropertySource("/test.properties") 
class MyIntegrationTests {
    // class body...
}
```

下面的示例演示了如何声明内联属性：

```java
@ContextConfiguration
@TestPropertySource(properties = { "timezone = GMT", "port: 4242" }) 
class MyIntegrationTests {
    // class body...
}
```

有关示例和更多详细信息，请参见 [Context Configuration with Test Property Sources](https://docs.spring.io/spring-framework/docs/5.3.2/reference/html/testing.html#testcontext-ctx-management-property-sources)。

**`@DynamicPropertySource`**

@DynamicPropertySource是一种方法级别注解，您可以使用它来注册动态属性，该动态属性会添加到集成测试中已加载的ApplicationContext的Environment中的PropertySources。当您不知道预期属性的值时，动态属性将很有用 - 例如，如果属性由外部资源管理，例如由[Testcontainers](https://www.testcontainers.org/)项目管理的容器。

以下示例演示了如何注册动态属性：

```java
@ContextConfiguration
class MyIntegrationTests {

    static MyExternalServer server = // ...

    @DynamicPropertySource 
    static void dynamicProperties(DynamicPropertyRegistry registry) { 
        registry.add("server.port", server::getPort); //从服务器懒加载
    }

    // tests ...
}
```

参考[Context Configuration with Dynamic Property Sources](https://docs.spring.io/spring-framework/docs/5.3.2/reference/html/testing.html#testcontext-ctx-management-dynamic-property-sources)以获取更多信息。

**`@DirtiesContext`**

@DirtiesContext表明，在执行测试期间，基础Spring ApplicationContext已被污染（即，测试以某种方式修改或损坏了上上下文，例如，通过更改单例bean的状态），应关闭它。当将应用程序上下文标记为污染时，将其从测试框架的缓存中删除并关闭。结果，对于需要具有相同配置元数据的上下文的任何后续测试，重建基础Spring容器。

您可以将@DirtiesContext用作同一类或类层次结构中的类和方法级注解。在这种情况下，根据配置的methodMode和classMode，ApplicationContext在任何注解方法以及当前测试类之前或之后都标记为污染。

以下示例说明了各种配置场景的上下文何时会污染：

- 在当前测试类之前，类模式设置为BEFORE_CLASS。

```java
@DirtiesContext(classMode = BEFORE_CLASS) //	Dirty the context before the current test class.
class FreshContextTests {
    // some tests that require a new Spring container
}
```

- 在当前测试类之后，类模式设置为AFTER_CLASS（默认类模式）。

```java
@DirtiesContext //	Dirty the context after the current test class.
class ContextDirtyingTests {
    // some tests that result in the Spring container being dirtied
}
```

- 在当前测试类中的每种测试方法之前，类模式设置为BEFORE_EACH_TEST_METHOD。

```java
@DirtiesContext(classMode = BEFORE_EACH_TEST_METHOD) //	Dirty the context before each test method.
class FreshContextTests {
    // some tests that require a new Spring container
}
```

- 在当前测试类中的每种测试方法之后，类模式设置为AFTER_EACH_TEST_METHOD。

```java
@DirtiesContext(classMode = AFTER_EACH_TEST_METHOD) //Dirty the context after each test method
class ContextDirtyingTests {
    // some tests that result in the Spring container being dirtied
}
```

- 在当前测试之前，将方法模式设置为BEFORE_METHOD。

```java
@DirtiesContext(methodMode = BEFORE_METHOD) //Dirty the context before the current test method.
@Test
void testProcessWhichRequiresFreshAppCtx() {
    // some logic that requires a new Spring container
}
```

- 在当前测试之后，将方法模式设置为AFTER_METHOD（默认方法模式）。

```java
@DirtiesContext //Dirty the context after the current test method.
@Test
void testProcessWhichDirtiesAppCtx() {
    // some logic that results in the Spring container being dirtied
}
```

如果将@DirtiesContext用在上下文作为使用@ContextHierarchy的上下文层次结构的一部分的测试中，则可以使用hierarchyMode标志来控制上下文缓存的清除方式。默认情况下，详尽的算法用于清除上下文缓存，不仅包括当前级别，还包括所有其他上下文层次结构，它们共享当前测试共有的祖上下文。存在于共同祖先上下文的子层结构中的所有ApplicationContext实例都从上下文缓存中删除并关闭。如果详尽的算法不适用于特定用例，则可以指定更简单的当前级算法，如以下示例所示：

```java
@ContextHierarchy({
    @ContextConfiguration("/parent-config.xml"),
    @ContextConfiguration("/child-config.xml")
})
class BaseTests {
    // class body...
}

class ExtendedTests extends BaseTests {

    @Test
    @DirtiesContext(hierarchyMode = CURRENT_LEVEL) 
    void test() {
        // some logic that results in the child context being dirtied
    }
}
```

有关EXHAUSTIVE和CURRENT_LEVEL算法的更多详细信息，请参见[`DirtiesContext.HierarchyMode`](https://docs.spring.io/spring-framework/docs/5.3.2/javadoc-api/org/springframework/test/annotation/DirtiesContext.HierarchyMode.html) javadoc。

**`@TestExecutionListeners`**

@TestExecutionListeners定义了用于配置应在TestContextManager注册的TestExecutionListener实现的类级元数据。通常，@TestExecutionListeners与@ContextConfiguration结合使用。

以下示例显示了如何注册两个TestExecutionListener实现：

```java
@ContextConfiguration
@TestExecutionListeners({CustomTestExecutionListener.class, AnotherTestExecutionListener.class}) 
class CustomTestExecutionListenerTests {
    // class body...
}
```

默认情况下，@TestExecutionListeners为从超类或包装类继承的监听器提供支持。有关示例和更多详细信息，请参见 [`@Nested` test class configuration](https://docs.spring.io/spring-framework/docs/5.3.2/reference/html/testing.html#testcontext-junit-jupiter-nested-test-configuration)和 [`@TestExecutionListeners` javadoc](https://docs.spring.io/spring-framework/docs/5.3.2/javadoc-api/org/springframework/test/context/TestExecutionListeners.html) 。

**`@Commit`**

@Commit表示在测试方法完成后应进行事务测试方法的提交。您可以将@Commit用作@Rollback(false)的直接替换，以更明确地传达代码的意图。类似于@Rollback，@Commit也可以声明为类级或方法级注解。

以下示例显示了如何使用@Commit：

```java
@Commit 
@Test
void testProcessWithoutRollback() {
    // ...
}
```

**`@Rollback`**

@Rollback表明在测试方法完成后是否应将事务测试方法的事务回滚。如果是true，则事务将回滚。否则，事务将被提交。在Spring TestContext 框架中即使未明确声明@Rollback，进行集成测试的回滚默认为true。

当声明为类级注解时， @Rollback定义了测试类层次结构中所有测试方法的默认回滚语义。当声明为方法级注解时， @Rollback定义了特定测试方法的回滚语义，可能会覆盖类级别的@Rollback或@Commit语义。

下面的示例导致测试方法的结果不回滚（也就是说，结果已提交到数据库）：

```java
@Rollback(false) 
@Test
void testProcessWithoutRollback() {
    // ...
}
```

**`@BeforeTransaction`**

@BeforeTransaction表明应在启动事务之前运行带注解的void方法，对于已配置为通过使用Spring的 @Transactional在事务中运行的测试方法。@BeforeTransaction方法不必是public，并且可以在基于Java 8的接口默认方法上声明。

以下示例显示了如何使用@BeforeTransaction：

```java
@BeforeTransaction 
void beforeTransaction() {
    // logic to be run before a transaction is started
}
```



**`@AfterTransaction`**

@AfterTransaction表明应在事务结束之后运行带注解的void方法，对于已配置为通过使用Spring的 @Transactional在事务中运行的测试方法。@AfterTransaction方法不必是public，并且可以在基于Java 8的接口默认方法上声明。

以下示例显示了如何使用@AfterTransaction：

```java
@AfterTransaction 
void afterTransaction() {
    // logic to be run after a transaction has ended
}
```

**`@Sql`**

@Sql用于注解测试类或测试方法，以配置在集成测试期间针对给定数据库运行的SQL脚本。以下示例显示了如何使用它：

```java
@Test
@Sql({"/test-schema.sql", "/test-user-data.sql"}) 
void userTest() {
    // run code that relies on the test schema and test data
}
```

参考 [Executing SQL scripts declaratively with @Sql](https://docs.spring.io/spring-framework/docs/5.3.2/reference/html/testing.html#testcontext-executing-sql-declaratively) 获取更多细节。

**`@SqlConfig`**

@SqlConfig定义元数据用于确定如何解析和运行通过@Sql配置的SQL脚本。以下示例显示了如何使用它：

```java
@Test
@Sql(
    scripts = "/test-user-data.sql",
    config = @SqlConfig(commentPrefix = "`", separator = "@@") 
)
void userTest() {
    // run code that relies on the test data
}
```



**`@SqlMergeMode`**

@SqlMergeMode用于注解测试类或测试方法，以配置方法级别@Sql声明是否与类级别@Sql声明合并。如果未在测试类或测试方法上声明@SqlMergeMode，则默认情况下将使用OVERRIDE模式。通过OVERRIDE模式，方法级@Sql声明将有效地覆盖类级别的@Sql声明。

请注意，方法级@SqlMergeMode声明覆盖了类级声明。

以下示例显示了如何在类级别使用@SqlMergeMode：

```java
@SpringJUnitConfig(TestConfig.class)
@Sql("/test-schema.sql")
@SqlMergeMode(MERGE) 
class UserTests {

    @Test
    @Sql("/user-test-data-001.sql")
    void standardUserProfile() {
        // run code that relies on test data set 001
    }
}
```

以下示例显示了如何在方法级别使用@SqlMergeMode。

```java
@SpringJUnitConfig(TestConfig.class)
@Sql("/test-schema.sql")
class UserTests {

    @Test
    @Sql("/user-test-data-001.sql")
    @SqlMergeMode(MERGE) 
    void standardUserProfile() {
        // run code that relies on test data set 001
    }
}
```

**`@SqlGroup`**

@SqlGroup是一个容器注解，可以汇总几个@Sql注解。您可以本地使用@SqlGroup来声明几个嵌套@Sql注解，也可以与Java 8的可重复注解一起使用，其中可以在同一类或方法上多次声明@Sql，隐式地生成该容器注解。以下示例显示了如何声明SQL组：

```java
@Test
@SqlGroup({ 
    @Sql(scripts = "/test-schema.sql", config = @SqlConfig(commentPrefix = "`")),
    @Sql("/test-user-data.sql")
)}
void userTest() {
    // run code that uses the test schema and test data
}
```



### 3.4.2. 标准注解支持

以下注解支持Spring TestContext 框架的所有配置标准语。请注意，这些注解不是特定于测试，可以在Spring框架中的任何地方使用。

- `@Autowired`
- `@Qualifier`
- `@Value`
- `@Resource` (javax.annotation) 如果JSR-250存在
- `@ManagedBean` (javax.annotation) 如果JSR-250存在
- `@Inject` (javax.inject)如果JSR-330存在
- `@Named` (javax.inject)如果JSR-330存在
- `@PersistenceContext` (javax.persistence)如果JPA存在
- `@PersistenceUnit` (javax.persistence)如果JPA存在
- `@Required`
- `@Transactional` (org.springframework.transaction.annotation) *with [limited attribute support](https://docs.spring.io/spring-framework/docs/5.3.2/reference/html/testing.html#testcontext-tx-attribute-support)*

> :information_source: **JSR-250生命周期注解**
>
> 在Spring TestContext框架中，您可以在ApplicationContext中配置的任何组件上使用@PostConstruct和@PreDestroy的标准语义。但是，这些生命周期注解在实际的测试类中的使用有限制。
>
> 如果用@PostConstruct注解测试类中的方法，则该方法在基础测试框架的任何方法之前运行（例如，用Junit Jupiter的@BeforeEach注释的方法），并且适用于测试类中的每种测试方法。另一方面，如果用@PreDestroy注解测试类中的方法，则该方法永远不会运行。因此，在测试类中，我们建议您使用基础测试框架的测试生命周期回调，而不是@PostConstruct和@PreDestroy。

### 3.4.3. Spring JUnit4测试注解















