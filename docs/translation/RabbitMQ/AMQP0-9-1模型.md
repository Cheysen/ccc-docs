# 什么是AMQP 0-9-1

AMQP 0-9-1（高级消息队列协议）是一种消息传递协议，使客户端应用程序能够与消息中间件代理进行通信。

# 代理

消息代理接受来自发布者（发布消息的应用程序，也叫生产者）的消息并把它们路由到消费者（处理消息的应用程序）。

因为它是一个网络协议，所以发布者、消费者和代理都能部署在不同机器上。

# AMQP 0-9-1模型简介

AMQP 0-9-1模型如下：消息被发布到交换机（就像邮政局或邮箱）中，然后使用称为绑定（bindings）的规则分发消息副本到队列（queues）。然后，代理将消息传递给订阅队列的消费者，或者消费者按需从队列中获取消息。

![AMQP0-9-1模型图](../../assets/MQ/AMQP0-9-1模型图.png)

发布消息时，发布者可以定义各种消息属性（消息元数据）。其中一些元数据可以被代理使用，但是它的其余部分对代理完全不透明，并且仅被接收消息的应用程序使用。

网络是不可靠的，并且应用程序可能无法处理消息，因此AMQP 0-9-1模型具有*消息确认*（*message acknowledgements*）的概念：当消息被传递给消费者时，消费者会自动通知代理（如果应用程序开发人员选择这样做）。当使用消息确认机制时，在收到该消息（或消息组）的通知时，代理才会完全从队列中删除该消息。

在某些情况下，例如，当无法路由消息时，可以将消息返回给发布者、丢弃，或者，如果代理实现了扩展，则将这些消息推到所谓的“死信队列（dead letter queue）”中。发布者通过使用某些参数发布消息来选择如何处理这样的情况。

队列（Queues），交换（exchanges）和绑定（bindings）称为AMQP实体。

# AMQP 0-9-1是可编程协议

AMQP 0-9-1是一种可编程协议，即AMQP 0-9-1实体和路由规则主要由应用程序本身定义，而不是代理管理员。

因此，为协议操作定义了一系列规则如声明队列和交换机、定义他们之间的绑定、订阅队列等。

这给了应用程序开发人员很多自由，但也需要他们意识到潜在的定义冲突。在实践中，定义冲突是罕见的，并且通常表明存在错误配置。

应用程序声明所需的AMQP 0-9-1实体，定义必要的路由规则，并且可以在不再使用它们时删除AMQP 0-9-1实体。

# 交换机和交换类型

消息会发送到交换机，交换机是AMQP 0-9-1实体。交换传递消息，将其路由到零或多个队列中。使用的路由算法取决于交换类型和被称为绑定的规则。AMQP 0-9-1代理提供四种交换类型：

| Exchange type             | Default pre-declared names              |
| :------------------------ | :-------------------------------------- |
| Direct exchange直连交换机 | (Empty string) and amq.direct           |
| Fanout exchange扇形交换机 | amq.fanout                              |
| Topic exchange主题交换机  | amq.topic                               |
| Headers exchange头交换机  | amq.match (and amq.headers in RabbitMQ) |

除了交换类型之外，交换机还声明了许多属性，最重要的是：

- Name：交换机名称
- Durability (exchanges survive broker restart)：是否持久化。如果持久性，则代理重启后，交换机还存在
- Auto-delete (exchange is deleted when last queue is unbound from it)：当所有与之绑定的消息队列都完成了对此交换机的使用后，删掉它
- Arguments (optional, used by plugins and broker-specific features)：可选，插件和代理特定功能使用

交换机可以是持久化的或临时的。持久化的交换机在代理重新启动任然存在，而临时的不会（当代理重新在线时，他们必须被重新声明）。并非所有场景都需要持久化的交换机。